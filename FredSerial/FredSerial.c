/*	File:		FredSerial.c	Contains:	FredSerial physical layer	Written by:	xxx put writers here xxx	Copyright:	© 1994 by Catapult Entertainment, Inc., all rights reserved.	Change History (most recent first):		<12>	03/11/22	GEP		Set kConnListening, avoid reading ConnectToken on kConnOpen		<11>	02/11/22	GEP		Move serial initialization to _PInit() preventing buffer corruption.   		<10>	01/30/22	GEP		Ring-a-ding ding: Use connect token for ring signaling,		                            reworked _PUSetupServerTalk, ST/GT distinction.		 <9>	01/29/22	GEP		Added _POpenAsync and _PListenAsync for peer connection.		 <8>	01/09/22	GEP		SEGAOSIDLE is the cause of the transmission issues,		                            use PHTimer to prevent calling it every _PNetIdle execute.		 <7>	01/09/22	GEP		Clean up includes.		 <6>	01/08/22	GEP		What the FUCK is going on? What I'm doing wrong?		                            &REFGLOBAL(PGlobals,PHReadFifo) does not work in _PUReadTimeCallback. 		 <5>	01/06/22	GEP		Totally reworked to match PModem.c coding style.		 <4>	01/04/22	GEP		Removed sending kConnectToken on opening port, access Fred through macros.		 <3>	12/31/21	GEP		_PUAsyncReadDispatch dispatched correctly.		 <2>	12/28/21	GEP		_PUSetupServerTalk added.		 <1>	12/27/21	GEP		Copy & Paste from other sources, mainly SegaSerial.c/CESSerial.c	To Do:		- Replace kIdleTickle/PHTimer solution to give a better loading-expierence on screen	*/#include "heaps.h"#include "Errors.h"#include "Time.h"#include "utils.h"#include "PhysicalLayer.h"#include "FredSerialPriv.h"#include "PhysicalStructs.h"#include "TransportLayer.h"#include "Fifo.h"#include "ccitt.h"#include "NetErrors.h"#include "NetMisc.h"#include "Errors.h"#include "SegaVDP.h"#ifndef OFFSET#define OFFSET(type, field)		((int) &((type *) 0)->field)#endif#ifdef THINK_C#define THINKSUCKS#endif// extern protosOSErr	_PInit(void);OSErr	_POpen(char *config, unsigned long flags);OSErr	_PListen(char *config, long flags);OSErr	_POpenAsync(char *config, long flags);OSErr	_PListenAsync(char *config, long flags);OSErr	_PClose(void);OSErr	_PUOpenPort(Boolean listen, char *config);void	_PUClosePort(void);OSErr	_PNetIdle(NetParamBlock *pBlock);OSErr	_PWritePacketSync(WDS *sendBuffer);OSErr	_PWritePacketASync(WDS *sendBuffer);OSErr	_PUAsyncReadData(long numBytes, unsigned char *dataBuf);OSErr	_PUAsyncWriteFifoData(void);OSErr	_PUProcessIdle(void);short	_PUProcessSTIdle(unsigned short length);void	_PUAsyncReadDispatch(PGlobalType * glob, unsigned char prevChar);OSErr	_PUSetError(OSErr err);OSErr	_PCheckError(void);OSErr 	_PGetError(void);short	_PUReceiveBufferAvail(void);Boolean _PUSetupServerTalk(void);Boolean _PUTearDownServerTalk(void);OSErr	_PUAnswerAsync(char *config);OSErr	_PUCheckLine(void);OSErr	_PUCheckAnswer(Boolean hangupOnNoAnswer);Boolean _PUCheckRing(short playsnd);PGlobalType PGlobals;#define	GetGlobals()	((PGlobalType *) &REFGLOBAL(PGlobals,PHReadyBuffer))long _PhysicalLayerControl (short command, long data){PGlobalType		*globals;long			offset;short			error;short			count;	error = commandSelectorUnknown;	switch ( command )		{		case kHardInitialize:			/* allocate and initialize our globals */			GETMGRGLOBALSOFFSET(PGlobals,offset);			error = AllocateGlobalSpace (kPhysicalLayerManager, offset, sizeof(PGlobalType), (Ptr *) &globals);			if ( error != noErr )				{				return error;				}			/* install our selectors */			SetDispatchedFunction ( kPInit,					kPhysicalLayerManager,	_PInit );			SetDispatchedFunction ( kPOpen,					kPhysicalLayerManager,	_POpen );			SetDispatchedFunction ( kPListen,				kPhysicalLayerManager,	_PListen );			SetDispatchedFunction ( kPOpenAsync,			kPhysicalLayerManager,	_POpenAsync );			SetDispatchedFunction ( kPListenAsync,			kPhysicalLayerManager,	_PListenAsync );			SetDispatchedFunction ( kPClose,				kPhysicalLayerManager,	_PClose );			SetDispatchedFunction ( kPNetIdle,				kPhysicalLayerManager,	_PNetIdle );			SetDispatchedFunction ( kPWritePacketSync,		kPhysicalLayerManager,	_PWritePacketSync );			SetDispatchedFunction ( kPWritePacketASync,		kPhysicalLayerManager,	_PWritePacketASync );			SetDispatchedFunction ( kPUOpenPort,			kPhysicalLayerManager,	_PUOpenPort );			SetDispatchedFunction ( kPUSetError,			kPhysicalLayerManager,	_PUSetError );			SetDispatchedFunction ( kPGetError,				kPhysicalLayerManager,	_PGetError );			SetDispatchedFunction ( kPCheckError,			kPhysicalLayerManager,	_PCheckError );			SetDispatchedFunction ( kPUSetupServerTalk,		kPhysicalLayerManager,	_PUSetupServerTalk);			SetDispatchedFunction ( kPUTearDownServerTalk,	kPhysicalLayerManager,	_PUTearDownServerTalk);			SetDispatchedFunction ( kPUClosePort,			kPhysicalLayerManager,	_PUClosePort );			SetDispatchedFunction ( kPUProcessIdle,			kPhysicalLayerManager,	_PUProcessIdle );			SetDispatchedFunction ( kPUProcessSTIdle,		kPhysicalLayerManager,	_PUProcessSTIdle );			SetDispatchedFunction ( kPUReadSerialByte,		kPhysicalLayerManager,	_PUReadSerialByte );			SetDispatchedFunction ( kPUWriteSerialByte,		kPhysicalLayerManager,	_PUWriteSerialByte );			SetDispatchedFunction ( kPUTransmitBufferFree,	kPhysicalLayerManager,	_PUTransmitBufferFree );			SetDispatchedFunction ( kPUReceiveBufferAvail,	kPhysicalLayerManager,	_PUReceiveBufferAvail );			SetDispatchedFunction ( kPUTestForConnection,	kPhysicalLayerManager,	_PUTestForConnection );			SetDispatchedFunction ( kPUReadTimeCallback,	kPhysicalLayerManager,	_PUReadTimeCallback );			SetDispatchedFunction ( kPUWriteTimeCallback,	kPhysicalLayerManager,	_PUWriteTimeCallback );			SetDispatchedFunction ( kPUAsyncReadDispatch,	kPhysicalLayerManager,	_PUAsyncReadDispatch );			SetDispatchedFunction ( kPUAnswerAsync,			kPhysicalLayerManager,	_PUAnswerAsync );			SetDispatchedFunction ( kPUCheckLine,			kPhysicalLayerManager,	_PUCheckLine );			SetDispatchedFunction ( kPUCheckAnswer,			kPhysicalLayerManager,	_PUCheckAnswer );			SetDispatchedFunction ( kPUCheckRing,			kPhysicalLayerManager,	_PUCheckRing );			break;		case kSoftInialize:			error = noErr;			break;		case kHardClose:			error = noErr;			break;		case kSoftClose:			error = noErr;			break;		case kCodeBlockMoved:			error = noErr;			break;		case kGlobalsMoved:			error = noErr;			break;		}	return error;}OSErr _PInit(void){short			count;FREDPTR;	for (count = sizeof(PGlobalType)-1; count >= 0; count--)		((char *)&PGlobals)[count] = 0;		REFGLOBAL(PGlobals,PHMagic) = kMagicVal;	// set up buffers	REFGLOBAL(PGlobals,PHLengthsBuf) = NewMemory(kTemp,kFrameStartBufSiz);	ASSERT(REFGLOBAL(PGlobals,PHLengthsBuf));	REFGLOBAL(PGlobals,PHReadDataBuf) = NewMemory(kTemp,kPhysBufferSize);	ASSERT(REFGLOBAL(PGlobals,PHReadDataBuf));	REFGLOBAL(PGlobals,PHWriteDataBuf) = NewMemory(kTemp,kPhysBufferSize);	ASSERT(REFGLOBAL(PGlobals,PHWriteDataBuf));	REFGLOBAL(PGlobals,PHStagingBuf) = NewMemory(kTemp,kMaxPacket);	ASSERT(REFGLOBAL(PGlobals,PHStagingBuf));		*((long *)OFFSET(SegaLowMem,modemDebug)) = 0;		WRITE_FRED(kMStatus1,kMonestop+kMenstop+kMbit_8+kMresetModem+kMenModem);	WRITE_FRED(kBCnt,0x38);	WRITE_FRED(kBCnt+2,0x1);	WRITE_FRED(kMStatus1,kMonestop+kMenstop+kMbit_8+kMenModem);		return noErr;}OSErr _POpen(char *config, unsigned long flags){	return POpenAsync(config, flags);}OSErr _PListen(char *config, long flags){OSErr			err;		err = PListenAsync(config, flags);	if (err)		return err;		if (REFGLOBAL(PGlobals,serverTalk))	{		do	{			if (PNetIdle(nil) < 0)				break;			}		while (REFGLOBAL(PGlobals,PHConnState) == kConnListening);		if (REFGLOBAL(PGlobals,PHConnState) == kConnOpen)			return noErr;		else			return PGetError();	}	else	{		while (PUCheckRing(true) == false)			SEGAOSIDLE;		err = PUCheckAnswer(true);		return err;	}}OSErr _POpenAsync(char *config, long flags){OSErr			err;	REFGLOBAL(PGlobals,serverTalk) = !(flags & kDisableServerTalk);	err = PUOpenPort(kOriginate, config);	PUSetupServerTalk();		return err;}OSErr _PListenAsync(char *config, long flags){OSErr			err;			REFGLOBAL(PGlobals,serverTalk) = !(flags & kDisableServerTalk);	err = PUOpenPort(kListen, config);	if (err)		return err;			return PUAnswerAsync(config);}OSErr _PClose(void){	PUClosePort();	return noErr;}OSErr _PUOpenPort(Boolean listen, char *config){	PCheckError();	return noErr;}void _PUClosePort(void){	PUTearDownServerTalk();	RemoveTimeRequest(REFGLOBAL(PGlobals,PHReadTimeRef));	RemoveTimeRequest(REFGLOBAL(PGlobals,PHWriteTimeRef));}Boolean _PUSetupServerTalk(){	if (!REFGLOBAL(PGlobals,serverTalk))		return false;			// set up the fifo	FifoInit(&REFGLOBAL(PGlobals,PHReadFifo), REFGLOBAL(PGlobals,PHReadDataBuf), kPhysBufferSize, kCircularQ);	FifoInit(&REFGLOBAL(PGlobals,PHWriteFifo), REFGLOBAL(PGlobals,PHWriteDataBuf), kPhysBufferSize, kCircularQ);	FifoInit(&REFGLOBAL(PGlobals,PHLengthsFifo), REFGLOBAL(PGlobals,PHLengthsBuf), kFrameStartBufSiz, kCircularQ);	REFGLOBAL(PGlobals,PHFrameSizAccum) = 0;	REFGLOBAL(PGlobals,PHTimer) = 0;		// remove this if we are GT/ST coresident	REFGLOBAL(PGlobals,PHPacketState) = kProcessingST;	REFGLOBAL(PGlobals,PHReadTimeRef) = AddTimeRequest((TimeRequestProc)_PUReadTimeCallback, 0);	REFGLOBAL(PGlobals,PHWriteTimeRef) = AddTimeRequest((TimeRequestProc)_PUWriteTimeCallback, 0);	REFGLOBAL(PGlobals,PHConnState) = kConnOpen;			return true;}Boolean _PUTearDownServerTalk(void){NetParamBlock	pBlock;unsigned long	stopTime, read, write, lastRead, lastWrite;	if (!REFGLOBAL(PGlobals,serverTalk))		return false;	if (NetIdle(&pBlock) < 0) 		CheckError();	else {		stopTime = GetCurrentTime() + kCloseTimeout;		while ((pBlock.ioPhysNetState == kConnOpen) && (stopTime < GetCurrentTime())) {			if (NetIdle(&pBlock) < 0) {				CheckError();				break;				}						read = FifoAvailable(&REFGLOBAL(PGlobals,PHReadFifo));			write = FifoAvailable(&REFGLOBAL(PGlobals,PHWriteFifo));			if ((lastRead != read) || (lastWrite != write)) {				lastRead = read;				lastWrite = write;				stopTime = GetCurrentTime() + kCloseTimeout;				}			}		}	REFGLOBAL(PGlobals,serverTalk) = 0;			// ServerTalk is now "off"	return true;}// NetIdle -- returns negative gen purpose error code on failure.OSErr _PNetIdle(NetParamBlock *pBlock){	// prevent PNetIdle from running if serverTalk has been disabled.	if (!REFGLOBAL(PGlobals,serverTalk))		return noErr;	if (GetCurrentTime() > REFGLOBAL(PGlobals,PHTimer)) {		SEGAOSIDLE;		REFGLOBAL(PGlobals,PHTimer) = GetCurrentTime() + kIdleTickle;		}		PCheckError();	if (pBlock) {		pBlock->ioPhysNetState = kConnClosed;		pBlock->ioLastPhysicalError = noErr;		pBlock->ioAvailable = 0;		pBlock->ioTotal = REFGLOBAL(PGlobals,PHTotal);		}	if (REFGLOBAL(PGlobals,PHConnState) != kConnClosed)	{		switch(PGetError())		{			case kFrameError:				MESG("FredSerial Frame Error");				PCheckError();				break;			case kOverrunError:				MESG("FredSerial Overrun Error");				PCheckError();				break;			default:				break;		}				if (pBlock)			pBlock->ioPhysNetState = REFGLOBAL(PGlobals,PHConnState);		return PUProcessIdle();		}	else		// return the last error		return PGetError();}OSErr _PWritePacketSync(WDS *sendBuffer){OSErr			err;	if (err = PGetError()) {		ERROR_MESG("Outstanding error has not been cleared");		return err;		}	if (REFGLOBAL(PGlobals,PHConnState) != kConnOpen) 		return PUSetError(kLinkClosed);	err = PWritePacketASync(sendBuffer);	if (err) return err;		while (REFGLOBAL(PGlobals,PHWriteActive)) {		err = PNetIdle(nil);		if (err < 0) return err;		}			return noErr;}// queue small chunks as we find kDLEChar's scattered through the outgoing buffer// called by TWriteDataSync, and in turn TWriteDataASyncOSErr _PWritePacketASync(WDS *sendBuffer){OSErr			theErr;long			bufLength, iter, padPoint;unsigned char	*addr;unsigned short	crc;Boolean			doingFCS;	if (theErr = PGetError()) {		ERROR_MESG("Outstanding error has not been cleared");		return theErr;		}	if (REFGLOBAL(PGlobals,PHConnState) != kConnOpen) 		return PUSetError(kLinkClosed);	// for those bad days when everything is a frame char, the worst case packet size is 2x	bufLength = (sendBuffer->length1 + sendBuffer->length2 + kFCSSize + kFramingSize) * 2;	if (FifoRemaining(&REFGLOBAL(PGlobals,PHWriteFifo)) < bufLength) {		// we have more to write than the fifo can handle.  Idle here if		// if the buffer is big enough to ever handle it, otherwise idle until		// FifoAvailable is zero and switch buffers.		if (FifoSize(&REFGLOBAL(PGlobals,PHWriteFifo)) > bufLength) {			// the fifo can handle it, just not right now.  Idle a bit			while (FifoRemaining(&REFGLOBAL(PGlobals,PHWriteFifo)) < bufLength) {				theErr = PNetIdle(nil);				if (theErr < 0) return theErr;				}			}		else {			// the buffer is bigger than the fifo			ASSERT_MESG(0,"The packet write fifo isn't big enough to for this buffer");			}		}				bufLength = sendBuffer->length1;	addr = sendBuffer->buf1;	padPoint = iter = 0;	crc = 0xffff;	doingFCS = false;	while (1) {		// (doingFCS == true) signals the writing of the FCS itself		if (!doingFCS)			crc = ccitt_updcrc(crc, (unsigned char *)addr, bufLength);		while (iter < bufLength) {			if (addr[iter] == kDLEChar) {				iter += 1;				theErr = FifoWrite(&REFGLOBAL(PGlobals,PHWriteFifo), &addr[padPoint], iter - padPoint);				if (theErr) return PUSetError(theErr);				if (iter <= bufLength) {					// send a pad					theErr = FifoWrite(&REFGLOBAL(PGlobals,PHWriteFifo), &addr[iter-1], 1);					if (theErr) return PUSetError(theErr);					padPoint = iter;					}				}			else {				iter += 1;				if (iter == bufLength) {					// flush the rest of the buffer					theErr = FifoWrite(&REFGLOBAL(PGlobals,PHWriteFifo), &addr[padPoint], bufLength - padPoint);					if (theErr) return PUSetError(theErr);					}				}			}		if (doingFCS)			break;		else if (addr == sendBuffer->buf1) {			// if the address is the first buffer then it should be the second next loop			padPoint = iter = 0;			bufLength = sendBuffer->length2;			addr = sendBuffer->buf2;			}		else {			// if the address is not the FCS and not the first buffer then it 			// is the second and we should set up for the FCS			crc = ~crc;			padPoint = iter = 0;			bufLength = sizeof(crc);			addr = (unsigned char *)&crc;			doingFCS = true;			}		}			// send the framing	crc = (kDLEChar<<8) + kETXChar;	theErr = FifoWrite(&REFGLOBAL(PGlobals,PHWriteFifo), (unsigned char *)&crc, sizeof(crc));	if (theErr) return PUSetError(theErr);		// call netidle to get the write rolling	theErr = PNetIdle(nil);	if (theErr) return theErr;		return noErr;}OSErr _PUProcessIdle(void){short			frameSize, retVal;	if (REFGLOBAL(PGlobals,PHIndicating))		return noErr;			retVal = FifoRead(&REFGLOBAL(PGlobals,PHLengthsFifo), (unsigned char *)&frameSize, sizeof(short));	if (retVal == noErr) {		// Reset always returns noErr.  If it returns an error, then the goto code _WILL_ cause the		// packet stream to be permanently fucked!  Further, if an error comes back from ProcessIdle,		// the consumption _MUST_ be adjusted for the same reasons.  We can't code for an error from		// the adjust, so it is ignored.		retVal = FifoResetConsumption(&REFGLOBAL(PGlobals,PHReadFifo));		if (retVal) goto failed;		retVal = PUProcessSTIdle(frameSize);		FifoAdjustConsumption(&REFGLOBAL(PGlobals,PHReadFifo), frameSize);		}	else if (retVal == kFifoUnderflowErr)		retVal = noErr;	REFGLOBAL(PGlobals,PHIndicating) = false;	failed:	if (retVal)		PUSetError(retVal);	return retVal;}		short _PUProcessSTIdle(unsigned short length){short			retVal;	REFGLOBAL(PGlobals,PHIndicating) = true;	// checksum happens in the fifo to avoid gratuitous copying	if (FifoChkSum(&REFGLOBAL(PGlobals,PHReadFifo), length - kFramingSize) == 0x1D0F) {		retVal = FifoSkip(&REFGLOBAL(PGlobals,PHReadFifo), kPhysHdrSiz);		if (retVal) goto failed;				retVal = TIndication(&REFGLOBAL(PGlobals,PHReadFifo), REFGLOBAL(PGlobals,PHConnState), length - (kPhysHdrSiz + kFCSSize + kFramingSize));		if (retVal) goto failed;				retVal = FifoSkip(&REFGLOBAL(PGlobals,PHReadFifo), kFramingSize+kFCSSize);		if (retVal) goto failed;		}	else {		WARNING_MESG("Bad Packet Detected");		// just kill it all		retVal = FifoSkip(&REFGLOBAL(PGlobals,PHReadFifo), length);		if (retVal) goto failed;		}	REFGLOBAL(PGlobals,PHIndicating) = false;failed:		if (retVal)		PUSetError(retVal);	return retVal;		}long _PUReadTimeCallback(long time, long data){OSErr error;unsigned char byte;PGlobalType *glob;	if ( GetManagerGlobals ( kPhysicalLayerManager, (Ptr *) &glob, 0L ) != noErr )		{		/* BRAIN DAMAGE: things are really bad if we get here */		return 0;		}	error = PUReadSerialByte(&byte);	while (!error) {		error = FifoWrite(&glob->PHReadFifo, &byte, sizeof(byte));		if (error)			PUSetError(error);		PUAsyncReadDispatch(nil, byte);		error = PUReadSerialByte(&byte);		}			return time+1;}void _PUAsyncReadDispatch(PGlobalType * glob, unsigned char prevChar){	REFGLOBAL(PGlobals,PHFrameSizAccum) += 1;	if ((REFGLOBAL(PGlobals,PHPacketState) == kCheckNextST) && (prevChar == kETXChar)) {		// yep, the last one was a frame		FifoWrite(&REFGLOBAL(PGlobals,PHLengthsFifo), (unsigned char *)&REFGLOBAL(PGlobals,PHFrameSizAccum), sizeof(short));		REFGLOBAL(PGlobals,PHFrameSizAccum) = 0;		REFGLOBAL(PGlobals,PHPacketState) = kProcessingST; 			// reset for next time		}	else if (prevChar == kDLEChar) {					// found a DLE?		if (REFGLOBAL(PGlobals,PHPacketState) == kCheckNextST) { 		// yep, did we just see one?			FifoUnwrite(&REFGLOBAL(PGlobals,PHReadFifo), 1);			// yep, dump this one			// update fram size accumulator			REFGLOBAL(PGlobals,PHFrameSizAccum) -= 1;			REFGLOBAL(PGlobals,PHPacketState) = kProcessingST; 		// reset for next time			}		else											// didn't just see one, prepare to			REFGLOBAL(PGlobals,PHPacketState) = kCheckNextST;			// dump next one if there is one		}	else {		REFGLOBAL(PGlobals,PHPacketState) = kProcessingST; 			// either way the next is something!		}}long _PUWriteTimeCallback(long time, long unused){short			count;long			returnTime;unsigned long	fifoBytesAvailable;	returnTime = time + 1;	if ((REFGLOBAL(PGlobals,PHConnState) == kConnOpen) || (REFGLOBAL(PGlobals,PHConnState) == kConnListening)) 	{		fifoBytesAvailable = FifoAvailable(&REFGLOBAL(PGlobals,PHWriteFifo));		if (fifoBytesAvailable != 0) 		{			if (PUTransmitBufferFree() == noErr) 			{				count = kFIFOLENGTH;				if (fifoBytesAvailable > count)					fifoBytesAvailable = count;									REFGLOBAL(PGlobals,PHWriteActive) = true;				FifoRead(&REFGLOBAL(PGlobals,PHWriteFifo), REFGLOBAL(PGlobals,PHStagingBuf), fifoBytesAvailable);				for (count=0; count<fifoBytesAvailable; count++)					PUWriteSerialByte(REFGLOBAL(PGlobals,PHStagingBuf)[count]);			}		}		else 		{			REFGLOBAL(PGlobals,PHWriteActive) = false;		}	}			return returnTime;}OSErr _PUSetError(OSErr err){	REFGLOBAL(PGlobals,PHLastError) = err;	return err;}OSErr _PGetError(void){	return REFGLOBAL(PGlobals,PHLastError);}OSErr _PCheckError(void){OSErr			err;	err = REFGLOBAL(PGlobals,PHLastError);	REFGLOBAL(PGlobals,PHLastError) = noErr;	return err;}OSErr _PUReadSerialByte(unsigned char *byte){FREDPTR;short			error, result, mstatus1, mstatus2;	error = 0;	mstatus1 = READ_FRED(kReadMStatus1);	mstatus2 = READ_FRED(kReadMStatus2);	if (!(mstatus2 & kRMrxready))		error = kNoByteReady;	else {		if (mstatus2 & kRMframeerr)			error = kFrameError;		if (mstatus1 & kRMoverrun)			error = kOverrunError;		*byte = READ_FRED(kRxBuff);	}		return error;}OSErr _PUWriteSerialByte(unsigned char byte){FREDPTR;short			error, mstatus;	error = 0;	mstatus = READ_FRED(kReadMStatus1);	if (mstatus & kRMoverrun)		error = kOverrunError;	while (mstatus & kRMtxfull)		{			mstatus = READ_FRED(kReadMStatus1);			if (mstatus & kRMoverrun)				error = kOverrunError;		}	WRITE_FRED(kTxBuff,byte);	if (error)		PUSetError(error);	return error;}OSErr _PUTransmitBufferFree(void){FREDPTR;short			error;	error = kTransmitBufferFull;	if (!(READ_FRED(kReadMStatus1) & kRMtxfull))		error = 0;	return error;}short _PUReceiveBufferAvail(void){FREDPTR;	return READ_FRED(kReadMStatus2) & kRMrxready;}OSErr _PUTestForConnection(void){short			error;unsigned char	byte;	error = eNoConnection;	/* if we got a byte, make sure it's the connect token */	if (PUReadSerialByte(&byte) == 0)		{		if (byte == kConnectToken) {			error = 0;			}		}	if (error)		PUSetError(error);			return error;}OSErr _PUAnswerAsync(char *config){FREDPTR;	REFGLOBAL(PGlobals,PHConnState) = kConnListening;	return noErr;}OSErr _PUCheckLine(void){	return noErr;}OSErr _PUCheckAnswer(Boolean hangupOnNoAnswer){	PUSetupServerTalk();	REFGLOBAL(PGlobals,PHConnState) = kConnOpen;	return noErr;}Boolean _PUCheckRing(short playsnd){unsigned char	byte;OSErr			err;	if (REFGLOBAL(PGlobals,PHConnState) != kConnOpen) {		err = PUReadSerialByte(&byte);		if (!err && (byte == kConnectToken)) {			return true;			}		}				return false;}